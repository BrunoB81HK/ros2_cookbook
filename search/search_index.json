{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#ros-2-cookbook","title":"ROS 2 Cookbook","text":"<p>A collection of snippets ranging multiple topics in ROS 2.</p>"},{"location":"index.html#cookbook","title":"Cookbook","text":""},{"location":"index.html#contributing","title":"Contributing","text":""},{"location":"literate-nav.html","title":"Literate nav","text":"<ul> <li>Client Librairies<ul> <li>C++<ul> <li>Initialization</li> <li>Logging</li> <li>Nodes</li> <li>Parameters</li> <li>Pcl</li> <li>Tf2</li> <li>Time</li> <li>Workarounds</li> </ul> </li> <li>Python<ul> <li>Logging</li> <li>Nodes</li> <li>Parameters</li> <li>Tf2</li> <li>Time</li> </ul> </li> </ul> </li> <li>Other<ul> <li>Bag</li> <li>Cmake</li> <li>Colcon</li> <li>Command_line</li> <li>Launch</li> <li>Networking</li> <li>Packages</li> <li>Rosdep</li> </ul> </li> </ul>"},{"location":"client_libraries/index.html","title":"Client Librairies","text":""},{"location":"client_libraries/index.html#client-libraries","title":"Client libraries","text":""},{"location":"client_libraries/index.html#c-rclcpp","title":"C++ (rclcpp)","text":""},{"location":"client_libraries/index.html#python-rclpy","title":"Python (rclpy)","text":""},{"location":"client_libraries/rclcpp/index.html","title":"C++","text":""},{"location":"client_libraries/rclcpp/index.html#c-rclcpp","title":"C++ (rclcpp)","text":""},{"location":"client_libraries/rclcpp/index.html#nodes","title":"Nodes","text":""},{"location":"client_libraries/rclcpp/index.html#parameters","title":"Parameters","text":""},{"location":"client_libraries/rclcpp/index.html#logging","title":"Logging","text":""},{"location":"client_libraries/rclcpp/index.html#time","title":"Time","text":""},{"location":"client_libraries/rclcpp/index.html#tf2","title":"TF2","text":""},{"location":"client_libraries/rclcpp/index.html#point-clouds","title":"Point Clouds","text":""},{"location":"client_libraries/rclcpp/index.html#workarounds","title":"Workarounds","text":""},{"location":"client_libraries/rclcpp/index.html#initialization","title":"Initialization","text":""},{"location":"client_libraries/rclcpp/initialization.html","title":"rclcpp: Initialization","text":"<p>Sometime, you need to initialize some components outside of the constructor of your node. For example, you may want to initialize an object by passing a shared pointer to the node to it. This is not possible in the constructor, because the node is not fully initialized yet.</p> <p>The following pattern can be used to initialize components outside of the constructor of your node. This pattern was found through this comment.</p> <pre><code>// Class declaration\n\nclass InitializedComponent\n{\npublic:\n  COMPOSITION_PUBLIC\n  explicit InitializedComponent(const rclcpp::NodeOptions &amp; options);\n\n  COMPOSITION_PUBLIC\n  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr\n  get_node_base_interface() const;\n\nprivate:\n  rclcpp::Node::SharedPtr node_;\n};\n\n// Class implementation\n\nInitializedComponent::InitializedComponent(const rclcpp::NodeOptions &amp; options)\n: node_(std::make_shared&lt;rclcpp::Node&gt;(\"node\", options))\n{\n  /* Do some initialization here */\n}\n\nrclcpp::node_interfaces::NodeBaseInterface::SharedPtr\nInitializedComponent::get_node_base_interface() const\n{\n  return this-&gt;node_-&gt;get_node_base_interface();\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/logging.html","title":"rclcpp: Logging","text":""},{"location":"client_libraries/rclcpp/logging.html#changing-the-logging-level","title":"Changing the logging level","text":"<pre><code>#include &lt;rclcpp/logger.hpp&gt;\n\nrclcpp::get_logger(\"nav2_costmap_2d\").set_level(rclcpp::Logger::Level::Debug);\n</code></pre>"},{"location":"client_libraries/rclcpp/nodes.html","title":"rclcpp: Nodes and Components","text":""},{"location":"client_libraries/rclcpp/nodes.html#creating-a-component","title":"Creating a Component","text":"<p>ROS 2 introduces components, which are nodes that can be run together in a single process. The benefits of using node compositions has been documented in a recent paper, Impact of ROS 2 Node Composition in Robotic Systems. Given the ease of use and the provided tooling, it really makes sense to make just about every node a component, and then let the rclcpp_components tooling create a node executable for you:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n\nnamespace my_pkg\n{\n\nclass MyComponent : public rclcpp::Node\n{\npublic:\n  MyComponent(const rclcpp::NodeOptions&amp; options)\n  : rclcpp::Node(\"node_name\", options)\n  {\n    // Do all your setup here - subscribers/publishers/timers\n    // After you return, an executor will be started\n\n    // Note: you cannot use shared_from_this()\n    //       here because the node is not fully\n    //       initialized.\n  }\n};\n\n}  // namespace my_pkg\n\n#include \"rclcpp_components/register_node_macro.hpp\"\nRCLCPP_COMPONENTS_REGISTER_NODE(my_pkg::MyComponent)\n</code></pre> <p>The in the CMakeLists.txt:</p> <pre><code>add_library(my_component SHARED\n  src/my_component.cpp\n)\nament_target_dependencies(my_component\n  rclcpp\n  rclcpp_components\n)\n\n# Also add a node executable which simply loads the component\nrclcpp_components_register_node(my_component\n  PLUGIN \"my_pkg::MyComponent\"\n  EXECUTABLE my_node\n)\n</code></pre>"},{"location":"client_libraries/rclcpp/nodes.html#executors","title":"Executors","text":"<p>To run an executor in a thread:</p> <pre><code>#include &lt;thread&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp/executors/single_threaded_executor.hpp&gt;\n\nrclcpp::executors::SingleThreadedExecutor executor;\n\n// Node is rclcpp::Node::SharedPtr instance\nexecutor.add_node(node);\nstd::thread executor_thread(\n  std::bind(&amp;rclcpp::executors::SingleThreadedExecutor::spin,\n            &amp;executor));\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html","title":"rclcpp: Parameters","text":"<p>Parameters need to be declared. At the same time, you can get the value if you are not planning to update the value again later:</p> <pre><code>// node is an instance of rclcpp::Node\n// 42 is a great default for a parameter\nint param = node.declare_parameter&lt;int&gt;(\"my_param_name\", 42);\n</code></pre> <p>To get the value:</p> <pre><code>int param;\nnode.get_parameter(\"my_param_name\", param);\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html#dynamic-parameters","title":"Dynamic Parameters","text":"<p>In ROS 2, all parameters can be dynamically updated through a ROS 2 service (there is no need to define duplicate stuff as with dynamic reconfigure).</p> <p>The example below works in Eloquent or later (earlier ROS 2 releases supported only a single callback and had a slightly different API). See the documentation for rclcpp::ParameterType for valid types.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\nclass MyNode : public rclcpp::Node\n{\npublic:\n  MyNode()\n  {\n    // Declare parameters first\n\n    // Then create callback\n    param_cb_ = this-&gt;add_on_set_parameters_callback(\n      std::bind(&amp;MyNode::updateCallback, this, std::placeholders::_1));\n  }\n\nprivate:\n  // This will get called whenever a parameter gets updated\n  rcl_interfaces::msg::SetParametersResult updateCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters)\n  {\n    rcl_interfaces::msg::SetParametersResult result;\n    result.successful = true;\n\n    for (const rclcpp::Parameter &amp; param : parameters)\n    {\n      if (param.get_name() == \"my_param_name\")\n      {\n        if (param.get_type() != rclcpp::ParameterType::PARAMETER_STRING)\n        {\n          result.successful = false;\n          result.reason = \"my_param_name must be a string\";\n          break;\n        }\n\n        // Optionally do something with parameter\n      }\n    }\n\n    return result;\n  }\n\n  // Need to hold a pointer to the callback\n  rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr param_cb_;\n};\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html#porting-xml-arrays-to-ros-2","title":"Porting XML Arrays to ROS 2","text":"<p>Complex parameter blocks could be parsed as XML in ROS 1. For instance, the robot_calibration package used a block like:</p> <pre><code>models:\n - name: arm\n   type: chain\n   frame: wrist_roll_link\n - name: camera\n   type: camera3d\n   frame: head_camera_rgb_optical_frame\n</code></pre> <p>In ROS 2, the common pattern is to make the array a list of just names, then have each name be a block of parameters:</p> <pre><code>models:\n- arm\n- camera\narm:\n  type: chain3d\n  frame: wrist_roll_link\ncamera:\n  type: camera3d\n  frame: head_camera_rgb_optical_frame\n</code></pre> <p>To parse such a block:</p> <pre><code>std::vector&lt;ModelParams&gt; models;\nauto model_names = node-&gt;declare_parameter&lt;std::vector&lt;std::string&gt;&gt;(\"models\", std::vector&lt;std::string&gt;());\nfor (auto name : model_names)\n{\n  RCLCPP_INFO(logger, \"Adding model: %s\", name.c_str());\n  ModelParams params;\n  params.name = name;\n  params.type = node-&gt;declare_parameter&lt;std::string&gt;(name + \".type\", std::string());\n  params.frame = node-&gt;declare_parameter&lt;std::string&gt;(name + \".frame\", std::string());\n  params.param_name = node-&gt;declare_parameter&lt;std::string&gt;(name + \".param_name\", std::string());\n  models.push_back(params);\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/pcl.html","title":"rclcpp: Point Clouds","text":"<p>The sensor_msgs/PointCloud2 is a very common type of ROS message for processing perception data in ROS. It is also one of the most complex messages to actually interpret.</p> <p>The complexity of the message derives from the fact that it holds arbitrary fields in a single giant data store. This allows the PointCloud2 message to work with any type of cloud (for instance, XYZ points only, XYZRGB, or even XYZI), but adds a bit of complexity in accessing the data in the cloud.</p> <p>In ROS1, there was a simpler PointCloud message, but this has been deprecated and will be removed in ROS2-G.</p>"},{"location":"client_libraries/rclcpp/pcl.html#using-the-pointcloud2iterator","title":"Using the PointCloud2Iterator","text":"<p>The sensor_msgs package provides a C++ PointCloud2Iterator which can be used to create, modify and access PointCloud2 messages.</p> <p>To create a new message:</p> <pre><code>#include \"sensor_msgs/msg/point_cloud2.hpp\"\n#include \"sensor_msgs/point_cloud2_iterator.hpp\"\n\nsensor_msgs::msg::PointCloud2 msg;\n\n// Fill in the size of the cloud\nmsg.height = 480;\nmsg.width = 640;\n\n// Create the modifier to setup the fields and memory\nsensor_msgs::PointCloud2Modifier mod(msg);\n\n// Set the fields that our cloud will have\nmod.setPointCloud2FieldsByString(2, \"xyz\", \"rgb\");\n\n// Set up memory for our points\nmod.resize(msg.height * msg.width);\n\n// Now create iterators for fields\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_x(cloud_msg, \"x\");\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_y(cloud_msg, \"y\");\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_z(cloud_msg, \"z\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_r(cloud_msg, \"r\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_g(cloud_msg, \"g\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_b(cloud_msg, \"b\");\n\nfor (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z, ++iter_r, ++iter_g, ++iter_b)\n{\n  *iter_x = 0.0;\n  *iter_y = 0.0;\n  *iter_z = 0.0;\n  *iter_r = 0;\n  *iter_g = 255;\n  *iter_b = 0;\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/pcl.html#using-pcl","title":"Using PCL","text":"<p>For a number of operations, you might want to convert to a pcl::PointCloud in order to use the extensive API of the Point Cloud Library.</p> <p>In ROS1, the pcl_ros package allowed you to write a subscriber whose callback took a pcl::PointCloud directly, however this package has not yet been ported to ROS2. Regardless, it is pretty straight forward to do the conversion yourself with the pcl_conversions package:</p> <pre><code>#include \"pcl_conversions/pcl_conversions.h\"\n\nvoid cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)\n{\n  // PCL still uses boost::shared_ptr internally\n  pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud =\n    boost::make_shared&lt;pcl::PointCloud&lt;pcl::PointXYZRGB&gt;&gt;();\n\n  // This will convert the message into a pcl::PointCloud\n  pcl::fromROSMsg(*msg, *cloud);\n}\n</code></pre> <p>You can also go in the opposite direction:</p> <pre><code>#include \"pcl_conversions/pcl_conversions.h\"\n\npcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud;\nsensor_msgs::msg::PointCloud2 msg;\n\npcl::toROSMsg(*cloud, msg);\ncloud_publisher-&gt;publish(msg);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html","title":"rclcpp: TF2","text":"<p>The TF2 library provides easy access to transformations. All of the examples below require a dependency on the tf2_ros package.</p>"},{"location":"client_libraries/rclcpp/tf2.html#broadcasting-transforms","title":"Broadcasting Transforms","text":"<pre><code>#include &lt;tf2_ros/transform_broadcaster.h&gt;\nstd::unique_ptr&lt;tf2_ros::TransformBroadcaster&gt; broadcaster;\n\nbroadcaster = std::make_unique&lt;tf2_ros::TransformBroadcaster&gt;(nodePtr);\n\ngeometry_msgs::msg::TransformStamped transform;\ntransform.header.stamp = node-&gt;now();\ntransform.header.frame_id = \"odom\";\ntransform.child_frame_id = \"base_link\";\n\n// Fill in transform.transform.translation\n// Fill in transform.transform.rotation\n\nbroadcaster-&gt;sendTransform(transform);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#listening-for-transforms","title":"Listening for Transforms","text":"<pre><code>#include \"tf2_ros/transform_listener.h\"\n\nstd::shared_ptr&lt;tf2_ros::Buffer&gt; tf_buffer;\nstd::shared_ptr&lt;tf2_ros::TransformListener&gt; tf_listener;\n\nrclcpp::Node node(\"name_of_node\");\n\ntf_buffer.reset(new tf2_ros::Buffer(node.get_clock()));\ntf_listener.reset(new tf2_ros::TransformListener(*tf_buffer_));\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#applying-transforms","title":"Applying Transforms","text":"<p>TF2 can be extended by packages that provide implementations of transform. The tf2_geometry_msgs package provides these for _geometry_msgs. The example below uses geometry_msgs::msg::PointStamped - but this should work for any data type in geometry_msgs:</p> <pre><code>#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.h&gt;\n\ngeometry_msg::msgs::PointStamped in, out;\nin.header.frame_id = \"source_frame\";\n\ntry\n{\n  tf_buffer-&gt;transform(in, out, \"target_frame\");\n}\ncatch (const tf2::TransformException&amp; ex)\n{\n  RCLCPP_ERROR(rclcpp::get_logger(\"logger_name\"), \"Could not transform point.\");\n}\n</code></pre> <p>The transform function can also take a timeout. It will then wait for the transform to be available up to that amount of time:</p> <pre><code>tf_buffer-&gt;transform(in, out, \"target_frame\", tf2::durationFromSec(1.0));\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#get-latest-transform","title":"Get Latest Transform","text":"<p>A common work flow is to get the \"latest\" transform. In ROS2, this can be accomplished using tf2::TimePointZero, but requires using lookupTransform and then calling doTransform (which is basically what transform does internally):</p> <pre><code>geometry_msgs::msg::PointStamped in, out;\n\ngeometry_msgs::msg::TransformStamped transform =\n   tf_buffer-&gt;lookupTransform(\"target_frame\",\n                              in.header.frame_id,\n                              tf2::TimePointZero);\n\ntf2::doTransform(in, out, transform);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#transform-from-eigenisometry3d","title":"Transform from Eigen::Isometry3d","text":"<pre><code>#include &lt;tf2_eigen/tf2_eigen.hpp&gt;\n\nEigen::Isometry3d map_to_odom;\ngeometry_msgs::msg::TransformStamped transform = tf2::eigenToTransform(map_to_odom);\n// Fill in header, child_frame_id\n</code></pre>"},{"location":"client_libraries/rclcpp/time.html","title":"rclcpp: Time","text":"<p>The rclcpp::Time and rclcpp::Duration are a significant departure from their ROS1 equivalents, but are more closely related to std::chrono. For an in-depth discussion comparing with std::chrono, see this discussion on ROS Discourse.</p> <p>When porting certain ROS1 libraries, there may be significant usage of timestamps as floating-point seconds. To get floating point seconds from an _rclcpp::Time_:</p> <pre><code>// node is instance of rclcpp::Node\nrclcpp::Time t = node.now();\ndouble seconds = t.seconds();\n</code></pre> <p>There is no constructor for Time from seconds represented by a floating point, so you first need to convert to nanoseconds:</p> <pre><code>rclcpp::Time t(static_cast&lt;uin64_t&gt;(seconds * 1e9));\n</code></pre> <p>rclcpp::Duration does have functions to go both directions:</p> <pre><code>rclcpp::Duration d = rclcpp::Duration::from_seconds(1.0);\ndouble seconds = d.seconds();\n</code></pre> <p>Unlike ROS1, sleeping does NOT occur from a Duration instance:</p> <pre><code>rclcpp::sleep_for(std::chrono::milliseconds(50));\n</code></pre>"},{"location":"client_libraries/rclcpp/time.html#api-documentation-links","title":"API Documentation Links","text":"<ul> <li>rclcpp::Time</li> <li>rclcpp::Duration</li> </ul>"},{"location":"client_libraries/rclcpp/workarounds.html","title":"rclcpp: Workarounds","text":""},{"location":"client_libraries/rclcpp/workarounds.html#lazy-publishers","title":"Lazy Publishers","text":"<p>Prior to the Iron release, ROS 2 did not support subscriber connect callbacks. This code creates a function which is called periodically to check if we need to start or stop subscribers:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;std_msgs/msg/float64.hpp&gt;\n\nclass LazyPublisherEx : rclcpp::Node\n{\npublic:\n  LazyPublisherEx(const rclcpp::NodeOptions &amp; options) :\n    Node(\"lazy_ex\", options)\n  {\n    // Setup timer\n    timer = this-&gt;create_wall_timer(\n      std::chrono::seconds(1),\n      std::bind(&amp;LazyPublisher::periodic, this));\n  }\n\nprivate:\n  void periodic()\n  {\n    if (pub_.get_subscription_count() &gt; 0)\n    {\n        // We have a subscriber, do any setup required\n    }\n    else\n    {\n        // Subscriber has disconnected, do any shutdown\n    }\n  }\n\n  rclcpp::Publisher&lt;std_msgs::msg::Float64&gt;::SharedPtr pub_;\n  rclcpp::TimerBase::SharedPtr timer_;\n};\n</code></pre> <p>The same can be done when using image transport, you simply have to change from get_subscription_count to getNumSubscribers:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;image_transport/image_transport.h&gt;\n\nclass LazyPublisherEx : rclcpp::Node\n{\npublic:\n  LazyPublisherEx(const rclcpp::NodeOptions &amp; options) :\n    Node(\"lazy_ex\", options)\n  {\n    // Setup timer\n    timer = this-&gt;create_wall_timer(\n      std::chrono::seconds(1),\n      std::bind(&amp;LazyPublisher::periodic, this));\n  }\n\nprivate:\n  void periodic()\n  {\n    if (pub_.getNumSubscribers() &gt; 0)\n    {\n        // We have a subscriber, do any setup required\n    }\n    else\n    {\n        // Subscriber has disconnected, do any shutdown\n    }\n  }\n\n  image_transport::CameraPublisher pub_;\n  rclcpp::TimerBase::SharedPtr timer_;\n};\n</code></pre>"},{"location":"client_libraries/rclpy/index.html","title":"Python","text":""},{"location":"client_libraries/rclpy/index.html#python-rclpy","title":"Python (rclpy)","text":""},{"location":"client_libraries/rclpy/index.html#nodes","title":"Nodes","text":""},{"location":"client_libraries/rclpy/index.html#parameters","title":"Parameters","text":""},{"location":"client_libraries/rclpy/index.html#logging","title":"Logging","text":""},{"location":"client_libraries/rclpy/index.html#time","title":"Time","text":""},{"location":"client_libraries/rclpy/index.html#tf2","title":"TF2","text":""},{"location":"client_libraries/rclpy/logging.html","title":"rclcpp: Logging","text":""},{"location":"client_libraries/rclpy/logging.html#changing-the-logging-level","title":"Changing the logging level","text":"<pre><code>#include &lt;rclcpp/logger.hpp&gt;\n\nrclcpp::get_logger(\"nav2_costmap_2d\").set_level(rclcpp::Logger::Level::Debug);\n</code></pre>"},{"location":"client_libraries/rclpy/nodes.html","title":"rclpy: Node Basics","text":"<p>Most nodes have publishers and subscribers, both of which are creating by calling functions of the Node instance:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__('my_node_name')\n\n        self.publisher = self.create_publisher(String, 'output_topic', 10)\n        self.subscription = self.create_subscription(\n            String,\n            'input_topic',\n            self.callback,\n            10)\n\n    def callback(self, msg):\n        self.get_logger().info(\"Recieved: %s\" % msg.data)\n        self.publisher.publish(msg)\n\nif __name___ == \"__main__\":\n    rclpy.init()\n    my_node = MyNode()\n    rclpy.spin(my_node)\n    my_node.destroy_node()  # cleans up pub-subs, etc\n    rclpy.shutdown()\n</code></pre>"},{"location":"client_libraries/rclpy/nodes.html#shutdown-hooks","title":"Shutdown Hooks","text":"<p>ROS1 had rospy.on_shutdown() - but there is not an equivalent in ROS2. It really is not needed though, since we manually shut things down rather than was the case in rospy which used many global variables:</p> <pre><code>try:\n    rclpy.spin(my_node)\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    my_node.on_shutdown()  # do any custom cleanup\n    my_node.destroy_node()\n    rclpy.shutdown()\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html","title":"rclpy: Parameters","text":""},{"location":"client_libraries/rclpy/parameters.html#declaring-and-accessing-parameters","title":"Declaring and Accessing Parameters","text":"<pre><code># node is rclpy.node.Node instance\n# 42 is a great default for a parameter\nnode.declare_parameter('my_param_name', 42)\n\n# To get the value:\nparam = node.get_parameter('my_param_name').value\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html#declaring-multiple-parameters-at-once","title":"Declaring Multiple Parameters at Once","text":"<p>There seems to be a fairly undocumentated part of the rclpy API:</p> <pre><code>node.declare_parameters(\n    namespace='',\n    parameters=[\n        ('my_param_name', 'default value'),\n        ('my_other_param', 42)\n    ]\n)\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html#dynamic-parameters","title":"Dynamic Parameters","text":"<p>In ROS2, all parameters can be dynamically updated through a ROS2 service (there is no need to define duplicate stuff as with dynamic reconfigure).</p> <pre><code>from rcl_interfaces.msg import SetParametersResult\n\nimport rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__('my_node_name')\n\n        # Declare a parameter\n        self.declare_parameter('my_param_name', 42)\n\n        # Then create callback\n        self.add_on_set_parameters_callback(self.callback)\n\n    def callback(self, parameters):\n        result = SetParametersResult(successful=True)\n\n        for p in parameters:\n            if p.name == 'my_param_name':\n                if p.type_ != p.Type.INTEGER:\n                    result.successful = False\n                    result.reason = 'my_param_name must be an Integer'\n                    return result\n                if p.value &lt; 20:\n                    result.successful = False\n                    result.reason = 'my_param_name must be &gt;= 20;\n                    return result\n\n        # Return success, so updates are seen via get_parameter()\n        return result\n</code></pre> <p>For an example of calling the set_parameters service, see ROS Answers</p>"},{"location":"client_libraries/rclpy/tf2.html","title":"rclpy: TF2","text":"<p>The TF2 library provides easy access to transformations. All of the examples below require a dependency on the tf2_ros package.</p>"},{"location":"client_libraries/rclpy/tf2.html#listening-for-transforms","title":"Listening for Transforms","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__(\"my_node\")\n\n        self.buffer = Buffer()\n        self.listener = TransformListener(self.buffer, self)\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html#applying-transforms","title":"Applying Transforms","text":"<p>TF2 can be extended by packages that provide implementations of transform. The tf2_geometry_msgs package provides these for _geometry_msgs. The example below uses geometry_msgs.msg.PointStamped - but this should work for any data type in geometry_msgs:</p> <pre><code>from geometry_msgs.msg import PointStamped\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nimport tf2_geometry_msgs\n\n# Setup buffer/listener as above\n\np1 = PointStamped()\np1.header.frame_id = \"source_frame\"\n# fill in p1\n\np2 = buffer.transform(p1, \"target_frame\")\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html#transformations","title":"Transformations","text":"<p>In ROS1, tf included the transformations module. tf2 has no similar module. It is recommended to use transforms3d Python package, which is available through apt on Ubuntu 22.04:</p> <pre><code>sudo apt-get install python3-transforms3d\n</code></pre> <p>Or via pip on other operating systems:</p> <pre><code>sudo pip3 install transforms3d\n</code></pre> <p>For instance, to rotate a point:</p> <pre><code>import numpy as np\nfrom transforms3d.quaternion import quat2mat\n\n# Create rotation matrix from quaternion\nR = quat2mat([w, x, y, z])\n# Create a vector to rotate\nV = np.array([x, y, z]).reshape((3, 1))\n# Rotate the vector\nM = np.dot(R, V)\n\np = PointStamped()\np.point.x = M[0, 0]\np.point.y = M[1, 0]\np.point.z = M[2, 0]\n</code></pre> <p>Additionally, in ROS2 Humble there is the tf_transformations package which should make it as easy as changing your imports from tf.transformations to tf_transformations.</p>"},{"location":"client_libraries/rclpy/time.html","title":"rclpy: Time","text":"<p>To get the equivalent of rospy.Time.now(), you now need a ROS 2 node:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def some_func(self):\n        t = self.get_clock().now()\n        msg.header.stamp = t.to_msg()\n</code></pre> <p>Converting from Duration to messages is common:</p> <pre><code>import rclpy\nfrom rclpy.duration import Duration\n\nmsg.duration = Duration(seconds=1).to_msg()\n</code></pre>"},{"location":"client_libraries/rclpy/time.html#timers","title":"Timers","text":"<p>Timers are created from the Node:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__(\"my_node\")\n\n        # Create a timer that fires every quarter second\n        timer_period = 0.25\n        self.timer = self.create_timer(timer_period, self.callback)\n\n    def callback(self):\n        self.get_logger().info(\"timer has fired\")\n</code></pre>"},{"location":"client_libraries/rclpy/time.html#rates","title":"Rates","text":"<p>Using Rate objects in ROS 2 is a bit more complex than in ROS 1. Due to implementation details, we need to spin() or the sleep() function will block. This is most easily accomplished using a thread:</p> <pre><code>import threading\n\n# Run spin in a thread, make thread daemon so we don't have to join it to exit\nthread = threading.Thread(target=rclpy.spin, args=(node, ), daemon=True)\nthread.start()\n\nrate = node.create_rate(10)\nwhile rclpy.ok():\n    print('This prints at 10hz')\n    rate.sleep()\n</code></pre>"},{"location":"other/pages/index.html","title":"Other","text":""},{"location":"other/pages/index.html#other","title":"Other","text":""},{"location":"other/pages/index.html#ros2launch","title":"ros2launch","text":""},{"location":"other/pages/index.html#rosbag2","title":"rosbag2","text":""},{"location":"other/pages/index.html#networking-dds-cyclonedds","title":"Networking (DDS &amp; CycloneDDS)","text":""},{"location":"other/pages/index.html#command-line-tools","title":"Command Line Tools","text":""},{"location":"other/pages/index.html#colcon","title":"colcon","text":""},{"location":"other/pages/index.html#cmake","title":"CMake","text":""},{"location":"other/pages/index.html#rosdep","title":"rosdep","text":""},{"location":"other/pages/bag.html","title":"rosbag2","text":""},{"location":"other/pages/bag.html#common-command-line","title":"Common Command Line","text":"<ul> <li><code>ros2 bag record /topic1 /topic2</code></li> <li>When playing a bagfile back, you usually want clock topic:</li> <li><code>ros2 bag play &lt;bagfile&gt; --clock</code></li> <li>For nodes to use the clock topic, specify use_sim_time:</li> <li><code>ros2 run rviz2 rviz2 --ros-args -p use_sim_time:=true</code></li> </ul>"},{"location":"other/pages/bag.html#api-tutorials","title":"API Tutorials","text":"<p>The ROS documentation has tutorials for recording and playback, which are linked below. There is no official tutorial for reading from a bagfile in Python, the linked one comes from an MCAP tutorial:</p> <ul> <li>Record in C++</li> <li>Playback in C++</li> <li>Record in Python</li> <li>Playback in Python</li> </ul>"},{"location":"other/pages/bag.html#converting-bag-files-from-ros-1","title":"Converting Bag Files from ROS 1","text":"<p>The following works, assuming you are mainly using standard topics. For instance, I have converted a number of bagfiles intended for SLAM testing, which mainly consist of sensor_msgs::LaserScan, TF, and nav_msgs::Odometry data.</p> <p>The easiest route for converting bagfiles is to use <code>rosbags</code>:</p> <pre><code>sudo pip3 install rosbags\nrosbag-convert bagfile_name.bag\n</code></pre> <p>This will create a new folder with the name <code>bagfile_name</code> containing the SQLite file and the index file. At this point, you can inspect the bagfile:</p> <pre><code>ros2 bag info bagfile_name\n\nFiles:             bagfile_name.db3\nBag size:          65.7 MiB\nStorage id:        sqlite3\nROS Distro:        rosbags\nDuration:          122.298s\nStart:             Jun 15 2014 21:41:49.861 (1402882909.861)\nEnd:               Jun 15 2014 21:43:52.159 (1402883032.159)\nMessages:          35187\nTopic information: Topic: odom | Type: nav_msgs/msg/Odometry | Count: 12141 | Serialization Format: cdr\n                   Topic: tf | Type: tf2_msgs/msg/TFMessage | Count: 16939 | Serialization Format: cdr\n                   Topic: base_scan | Type: sensor_msgs/msg/LaserScan | Count: 4884 | Serialization Format: cdr\n                   Topic: odom_combined | Type: nav_msgs/msg/Odometry | Count: 1223 | Serialization Format: cdr\n</code></pre> <p>This bagfile is now useable in ROS 2. However, you can also go a bit further by compressing the bagfile, and migrating it to the new MCAP file format. First, create a YAML file to define the output format:</p> <pre><code># output_format.yaml\noutput_bags:\n- uri: bagfile_name_compressed\n  all: true\n  compression_mode: file\n  compression_format: zstd\n</code></pre> <p>Now, run the conversion:</p> <pre><code>ros2 bag convert -i bagfile_name -o output_format.yaml\n</code></pre> <p>Inspecting the new bag, we can see that compression is very nice - a 75% reduction in file size for my typical SLAM bag files:</p> <pre><code>ros2 bag info bagfile_name_compressed\n\nFiles:             bagfile_name_compressed.mcap.zstd\nBag size:          16.7 MiB\nStorage id:        mcap\nROS Distro:        rolling\nDuration:          122.298s\nStart:             Jun 15 2014 21:41:49.861 (1402882909.861)\nEnd:               Jun 15 2014 21:43:52.159 (1402883032.159)\nMessages:          35187\nTopic information: Topic: base_scan | Type: sensor_msgs/msg/LaserScan | Count: 4884 | Serialization Format: cdr\n                   Topic: odom | Type: nav_msgs/msg/Odometry | Count: 12141 | Serialization Format: cdr\n                   Topic: odom_combined | Type: nav_msgs/msg/Odometry | Count: 1223 | Serialization Format: cdr\n                   Topic: tf | Type: tf2_msgs/msg/TFMessage | Count: 16939 | Serialization Format: cdr\n</code></pre>"},{"location":"other/pages/bag.html#removing-tf-from-a-bagfile","title":"Removing TF from a Bagfile","text":"<p>I have often found that I needed to remove problematic TF data from a bagfile, usually filtering out the <code>odom-&gt;base_link</code> transform so that I can replace it with a more sophisticated filtered one. In this particular example we just toss the whole message out - but you could selectively remove the individual transform within the message and serialize the edited message back up.</p> <pre><code>import rosbag2_py\nfrom rclpy.serialization import deserialize_message\nfrom rosidl_runtime_py.utilities import get_message\n\nreader = rosbag2_py.SequentialReader()\nreader.open(\n    rosbag2_py.StorageOptions(uri='input_bag', storage_id='mcap'),\n    rosbag2_py.ConverterOptions(input_serialization_format='cdr',\n                                output_serialization_format='cdr')\n)\n\nwriter = rosbag2_py.SequentialWriter()\nwriter.open(\n    rosbag2_py.StorageOptions(uri='output_bag', storage_id='mcap'),\n    rosbag2_py.ConverterOptions('', '')\n)\n\n# First preprocess the topics\ntopic_types = reader.get_all_topics_and_types()\nfor topic_type in topic_types:\n    # Setup output bagfile - same topics as input\n    writer.create_topic(topic_type)\n    # Note the type if this is our TF data\n    if topic_type.name == '/tf':\n        tf_typename = topic_type.type\n\n# Now iterate through messages, copying over the ones we don't filter\nwhile reader.has_next():\n    topic, data, timestamp = reader.read_next()\n    filter_out = False\n    # Filter out odom tf messages\n    if topic == '/tf':\n        # Deserialize the message so we can look at it\n        msg_type = get_message(tf_typename)\n        msg = deserialize_message(data, msg_type)\n        # Iterate through the transforms in the message\n        for transform in msg.transforms:\n            if transform.header.frame_id == 'odom':\n                # Toss this message\n                filter_out = True\n                break\n    # Copy over message if it isn't odom\n    if not filter_out:\n        writer.write(topic, data, timestamp)\n</code></pre>"},{"location":"other/pages/cmake.html","title":"CMake","text":"<p>While you don't need to know everything about CMake to use ROS2, knowing a bit will really be helpful. You might be interested in the CMake tutorial which explains the basics of CMake.</p>"},{"location":"other/pages/cmake.html#ament","title":"Ament","text":"<p>Ament is a set of CMake modules specifically designed for ROS2 with the intent of making CMake easier to use. See also the Ament CMake documentation.</p> <p>The basic structure of an ament package:</p> <pre><code>cmake_minimum_required(VERSION 3.5)\nproject(my_package_name)\n\n# Default to C++14\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 14)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# Find packages\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\n\n# Include our own headers\ninclude_directories(include)\n\n# Create a node\nadd_executable(my_node src/my_node.cpp)\nament_target_dependencies(my_node\n  rclcpp\n  # Other ament dependencies\n  # This sets up include and linker paths\n)\n\nadd_library(my_library src/my_library.cpp)\nament_target_dependencies(my_library\n  rclcpp\n)\n\n# Install our headers\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n\n# Install our node and library\ninstall(TARGETS my_node my_library\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n  RUNTIME DESTINATION lib/${PACKAGE_NAME}\n)\n\n# Install some Python scripts\ninstall(\n  PROGRAMS\n    scripts/my_script.py\n  DESTINATION\n    lib/${PROJECT_NAME}\n)\n\n# Tell downstream packages where to find our headers\nament_export_include_directories(include)\n# Tell downstream packages our libraries to link against\nament_export_libraries(my_library)\n# Help downstream packages to find transitive dependencies\nament_export_dependencies(\n  rclcpp\n)\nament_package()\n</code></pre>"},{"location":"other/pages/cmake.html#linting-configuration","title":"Linting Configuration","text":"<p>I prefer a more ROS1-style code style. To allow braces to be on their own lines:</p> <pre><code>if(BUILD_TESTING)\n  find_package(ament_cmake_cpplint)\n  ament_cpplint(FILTERS \"-whitespace/braces\" \"-whitespace/newline\")\nendif()\n</code></pre>"},{"location":"other/pages/cmake.html#installing-python-scripts","title":"Installing Python Scripts","text":"<pre><code>install(\n  PROGRAMS\n    scripts/script1.py\n    scripts/script2.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre>"},{"location":"other/pages/cmake.html#depending-on-messages-in-same-package","title":"Depending on Messages in Same Package","text":"<p>It is generally best practice to put messages in separate packages, but sometimes, especially for drivers, you want the messages in the same package.</p> <p>The following example worked in earlier versions of ROS2 - but the syntax has changed See the Implementing custom interfaces tutorial for newer ROS2 distributions.</p> <pre><code># Note: this WILL NOT work in ROS2 Humble or later\nfind_package(rosidl_default_generators REQUIRED)\n\n# Generate some messages\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/MyMessage.msg\"\n)\n\n# Add a node which uses the messages\nadd_executable(my_node my_node.cpp)\nrosidl_target_interfaces(my_node ${PROJECT_NAME} \"rosidl_typesupport_cpp\")\n</code></pre>"},{"location":"other/pages/cmake.html#removing-boost-from-pluginlib","title":"Removing Boost from Pluginlib","text":"<p>Pluginlib supports both boost::shared_ptrs and std::shared_ptrs by default, if you want to avoid depending on Boost in your shiny new ROS2 library, you need to specifically tell pluginlib not to include the Boost versions:</p> <pre><code>target_compile_definitions(your_library PUBLIC \"PLUGINLIB__DISABLE_BOOST_FUNCTIONS\")\n</code></pre>"},{"location":"other/pages/cmake.html#using-eigen3","title":"Using Eigen3","text":"<p>Add eigen to your package.xml as a dependency, and then:</p> <pre><code>find_package(Eigen3 REQUIRED)\ninclude_directories(${EIGEN3_INCLUDE_DIRS})\n</code></pre>"},{"location":"other/pages/cmake.html#building-python-extensions-in-c","title":"Building Python Extensions in C++","text":"<p>The example below is based on the etherbotix package.</p> <pre><code>find_package(PythonLibs REQUIRED)\nfind_package(Boost REQUIRED python)\nfind_package(ament_cmake_python REQUIRED)\nfind_package(python_cmake_module REQUIRED)\n\nament_python_install_package(${PROJECT_NAME})\n\nadd_library(\n  my_python SHARED\n  ${SOURCE_FILES}\n)\nset_target_properties(\n  my_python PROPERTIES\n  LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}\n  PREFIX \"\"\n)\ntarget_link_libraries(my_python\n  ${Boost_LIBRARIES}\n  ${PYTHON_LIBRARIES}\n)\n\ninstall(\n  TARGETS my_python\n  DESTINATION \"${PYTHON_INSTALL_DIR}/${PROJECT_NAME}\"\n)\n</code></pre>"},{"location":"other/pages/colcon.html","title":"Command Line: Colcon","text":""},{"location":"other/pages/colcon.html#my-aliases","title":"My Aliases","text":"<p>I hate typing - so these are the aliases in my <code>~/.bashrc</code> for my most common workflow:</p> <pre><code>alias build2=\"colcon build --symlink-install\"\nalias test2=\"colcon test --event-handlers console_direct+\"\n</code></pre>"},{"location":"other/pages/colcon.html#build","title":"Build","text":"<p>colcon is used to build ROS2 packages in a workspace.</p> <p>Build all packages:</p> <pre><code>colcon build\n</code></pre> <p>To avoid having to rebuild when tweaking Python scripts, config files, and launch files:</p> <pre><code>colcon build --symlink-install\n</code></pre> <p>To fix most build issues, especially if you have added or removed packages to your workspace or installed new RMW implementations, clean the CMake cache. See this ROS Answers post for more details.</p> <pre><code>colcon build --cmake-clean-cache\n</code></pre>"},{"location":"other/pages/colcon.html#cmake-arguments","title":"CMake Arguments","text":"<pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo\n</code></pre>"},{"location":"other/pages/colcon.html#test","title":"Test","text":"<p>To test and get results to screen:</p> <pre><code>colcon test\ncolcon test-result --verbose\n</code></pre> <p>Build/test a single package:</p> <pre><code>colcon &lt;verb&gt; --packages-select &lt;package-name&gt;\n</code></pre>"},{"location":"other/pages/colcon.html#formatting","title":"Formatting","text":"<p>Get the output to the screen:</p> <pre><code>colcon &lt;verb&gt; --event-handlers console_direct+\n</code></pre>"},{"location":"other/pages/colcon.html#be-careful-with-workspaces","title":"Be Careful With Workspaces","text":"<p>You should probably build your workspace in a window where you have NOT sourced the setup.bash of that workspace. For more details on why, see this ticket.</p>"},{"location":"other/pages/colcon.html#verb-documentation","title":"Verb Documentation","text":"<ul> <li>build</li> <li>test</li> </ul>"},{"location":"other/pages/command_line.html","title":"Command_line","text":"<p>#    * <code>ros2 run &lt;pkg&gt; &lt;node&gt;</code>   #    * <code>ros2 node list</code>   #    * <code>ros2 topic list</code>   #    * <code>ros2 topic info &lt;topic_name&gt; --verbose</code> gives details about QoS.   #    * <code>ros2 param list</code>   #    * <code>ros2 doctor --report</code> gives tons of information.   <code>rosdep install --from-paths src --ignore-src --rosdistro=humble -y</code></p>"},{"location":"other/pages/launch.html","title":"roslaunch2","text":"<p>See also rosetta_launch for a number of examples.</p>"},{"location":"other/pages/launch.html#python-based-launch-files","title":"Python-Based Launch Files","text":"<p>Python-based launch files all pretty much follow the same structure.</p> <p>[!NOTE] Prior to Foxy, the parameters name, namespace, and executable were prefixed with node_</p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            name='node_runtime_name',\n            package='ros2_package_name',\n            executable='name_of_executable',\n            parameters=[{'name_of_int_param': 1,\n                         'name_of_str_param': 'value'}],\n            remappings=[('from', 'to')],\n            output='screen',\n        ),\n        # More Nodes!\n    ])\n</code></pre>"},{"location":"other/pages/launch.html#making-a-launch-file-executable","title":"Making a Launch File Executable","text":"<p>Normally, launch files are run with:</p> <pre><code>ros2 launch pkg launch.py\n</code></pre> <p>But, sometimes you want an executable launch file (for instance to put in a systemd job). Assuming you follow the default pattern shown above, all you need to add:</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\nfrom launch import LaunchService\n\n# define generate_launch_description() as above\n\nif __name__ == '__main__':\n    desc = generate_launch_description()\n    service = LaunchService(argv=sys.argv[1:])\n    service.include_launch_description(desc)\n    return service.run()\n</code></pre>"},{"location":"other/pages/launch.html#loading-parameters-from-a-file","title":"Loading Parameters From a File","text":"<p>Some nodes have many parameters, it's easier to put them in a YAML file:</p> <pre><code>node_name:\n  ros__parameters:\n      some_int_param: 1\n      some_str_param: \"the_value\"\n</code></pre> <p>To load this:</p> <pre><code>from ament_index_python.packages import get_package_share_directory\n\n# Assuming you have a file called package_name/config/params.yaml\nnode_params = os.path.join(\n    get_package_share_directory('package_name'),\n    'config',\n    'params.yaml'\n)\n\n# Add this to your LaunchDescription\nNode(\n    name='node_runtime_name',\n    package='ros2_package_name',\n    executable='name_of_executable',\n    parameters=[{'another_param': 42.0},\n                 node_params]\n)\n</code></pre>"},{"location":"other/pages/launch.html#including-python-launch-files","title":"Including Python Launch Files","text":"<pre><code>import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\n\n# Assuming you have a file called package_name/launch/my_launch.launch.py\nmy_launch_file = os.path.join(\n    get_package_share_directory('package_name'),\n    'launch',\n    'my_launch.launch.py'\n)\n\n# Add this to your LaunchDescription\nIncludeLaunchDescription(\n    PythonLaunchDescriptionSource([my_launch_file])\n),\n</code></pre>"},{"location":"other/pages/launch.html#loading-a-urdf","title":"Loading a URDF","text":"<p>Most robots need to load their URDF into the robot_state_publisher, and maybe other nodes as well:</p> <pre><code>import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch_ros.actions import Node\n\n# Load the URDF into a parameter\ndesc_dir = get_package_share_directory('robot_description_pkg')\nurdf_path = os.path.join(desc_dir, 'robots', 'my_urdf.urdf')\nurdf = open(urdf_path).read()\n\n# Add this to your LaunchDescription\nNode(\n    name='robot_state_publisher',\n    package='robot_state_publisher',\n    executable='robot_state_publisher',\n    parameters=[{'robot_description': urdf}],\n)\n</code></pre>"},{"location":"other/pages/launch.html#installing-launch-files","title":"Installing Launch Files","text":"<ul> <li>Launch System Tutorial</li> </ul>"},{"location":"other/pages/networking.html","title":"Networking","text":"<p>ROS2 uses DDS for message transport.</p> <p>Set the environment variable RMW_IMPLEMENTATION to select a DDS implementation (RMW = robotic middleware). For instance:</p> <pre><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n</code></pre> <p>To check which RMW implementation is being used:</p> <pre><code>ros2 doctor --report | grep middleware\n</code></pre>"},{"location":"other/pages/networking.html#dds-discovery","title":"DDS Discovery","text":"<p>There is no rosmaster like in ROS1. Node discovery is peer-to-peer with nodes announcing their topics on startup and periodically after that. By default, any machines on the same network will see each other if they have the same ROS_DOMAIN_ID.</p> <p>ROS_DOMAIN_ID can be any number between 0 and 253, although it is recommended to use numbers less than 128.</p> <p>In addition to the ROS_DOMAIN_ID, CycloneDDS supports a domain tag, which allows nearly infinite partitioning of the network (see below).</p> <p>If you want to limit communication to the localhost set ROS_LOCALHOST_ONLY, which is available since Eloquent.</p>"},{"location":"other/pages/networking.html#cyclonedds","title":"CycloneDDS","text":"<p>Cyclone can be configured with XML. This can be stored in a file or passed directly in the environment variable CYCLONEDDS_URI. A full list of supported options can be found in the eclipse-cyclonedds repo. See also the Guide to Configuration.</p>"},{"location":"other/pages/networking.html#cyclonedds-multiple-interfaces","title":"CycloneDDS: Multiple Interfaces","text":"<p>Cyclone currently only works with a single network interface. If you have multiple interfaces, specify which one to use in the NetworkInterfaceAddress:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;NetworkInterfaceAddress&gt;wlp2s0&lt;/NetworkInterfaceAddress&gt;\n    &lt;/General&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#cyclonedds-disabling-multicast-except-discovery","title":"CycloneDDS: Disabling Multicast (Except Discovery)","text":"<p>Some network hardware can perform poorly with multicast (especially with WIFI). You can limit multicast to just discovery:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;AllowMulticast&gt;spdp&lt;/AllowMulticast&gt;\n    &lt;/General&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#cyclonedds-domain-tag","title":"CycloneDDS: Domain Tag","text":"<p>CycloneDDS also defines a \"Domain Tag\" which allows to drastically partition the network with a custom string:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;Discovery&gt;\n      &lt;Tag&gt;my_robot_name&lt;/Tag&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#example","title":"Example","text":"<p>The above tags can all be combined:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;!-- Explicitly set network interface --&gt;\n      &lt;NetworkInterfaceAddress&gt;wlp2s0&lt;/NetworkInterfaceAddress&gt;\n      &lt;!-- Use multicast for discovery only --&gt;\n      &lt;AllowMulticast&gt;spdp&lt;/AllowMulticast&gt;\n    &lt;/General&gt;\n    &lt;Discovery&gt;\n      &lt;!-- This tag has to be the same on each machine --&gt;\n      &lt;Tag&gt;my_robot_name&lt;/Tag&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/packages.html","title":"Documentation","text":"<p>Currently, documentation is a bit all over the place. This list is certainly not extensive, but I find it helpful to have quick links to the frequently used packages.</p>"},{"location":"other/pages/packages.html#core-documentation","title":"Core Documentation","text":"<ul> <li>ROS 2 Overview</li> <li>Ament CMake</li> <li>ROS2 Launch</li> </ul>"},{"location":"other/pages/packages.html#higher-level-packages","title":"Higher Level Packages","text":"<ul> <li>MoveIt2</li> <li>Navigation2</li> </ul>"},{"location":"other/pages/rosdep.html","title":"Rosdep","text":"<p><code>rosdep install --from-paths src --ignore-src --rosdistro=humble -y</code></p>"}]}